\babel@toc {UKenglish}{}\relax 
\addvspace {10\p@ }
\contentsline {figure}{\numberline {1.1}{\ignorespaces \textit {Townscaper} uses \acrshort {wfc} with player input to develop worlds \blx@tocontentsinit {0}\cite {townscaper}}}{1}{figure.caption.9}%
\contentsline {figure}{\numberline {1.2}{\ignorespaces A complex Escheresque tile set that relies on modifying in blocks \blx@tocontentsinit {0}\cite {model_synthesis_diss}}}{2}{figure.caption.10}%
\contentsline {figure}{\numberline {1.3}{\ignorespaces Use of simple tiled \acrshort {wfc} to generate a circuit board graphic \blx@tocontentsinit {0}\cite {Gumin_Wave_Function_Collapse_2016}}}{2}{figure.caption.11}%
\contentsline {figure}{\numberline {1.4}{\ignorespaces A screenshot from the game included in the disseration}}{3}{figure.caption.12}%
\addvspace {10\p@ }
\contentsline {figure}{\numberline {2.1}{\ignorespaces \textit {Minecraft} lets the player explore an infinite, procedural world \blx@tocontentsinit {0}\cite {minecraft_screenshot}}}{5}{figure.caption.13}%
\contentsline {figure}{\numberline {2.2}{\ignorespaces Magic3D performs text-to-3D synthesis \blx@tocontentsinit {0}\cite {Magic3D}}}{5}{figure.caption.14}%
\contentsline {figure}{\numberline {2.3}{\ignorespaces Stable Diffusion offers text-to-image synthesis \blx@tocontentsinit {0}\cite {Stable_Diffusion}}}{6}{figure.caption.15}%
\contentsline {figure}{\numberline {2.4}{\ignorespaces Games generated using the Video Game Description Language \blx@tocontentsinit {0}\cite {VGDL}}}{6}{figure.caption.16}%
\contentsline {figure}{\numberline {2.5}{\ignorespaces CESAGAN extends upon Generative Adversarial Networks to encourage generation of playable levels requiring additional constraints (top) instead of unplayable levels (bottom) \blx@tocontentsinit {0}\cite {CESAGAN}}}{7}{figure.caption.17}%
\contentsline {figure}{\numberline {2.6}{\ignorespaces \acrlong {pcg} via Reinforcement Learning used to create \textit {Zelda} style levels. An initial random layout (a) is used with three different Markov Decision Process Representations (b), (c) and (d) to create playable levels. \blx@tocontentsinit {0}\cite {Markov_PCGRL}}}{7}{figure.caption.18}%
\contentsline {figure}{\numberline {2.7}{\ignorespaces A taxonomisation of \acrlong {pcg} Machine Learning techniques. There are two categorisations: the underlying data structure (graph, grid, or sequence) and the training method (matrix factorisation, EM, frequency counting, evolution, and backpropagation). Marks are colored for the specific type of content that was generated: red circles are platformer levels, orange squares are ``dungeons,'' the dark blue x is real time strategy levels, light blue triangles are collectible game cards, and the purple star is interactive fiction. Citations for each are listed. Citation numbers correspond to those in the cited paper. \blx@tocontentsinit {0}\cite {PCGML}}}{8}{figure.caption.19}%
\contentsline {figure}{\numberline {2.8}{\ignorespaces Basic model for the Algorithm Selection Problem \blx@tocontentsinit {0}\cite {Data_Mining_and_Constraint_Programming}}}{9}{figure.caption.20}%
\contentsline {figure}{\numberline {2.9}{\ignorespaces Examples of generated house plans \blx@tocontentsinit {0}\cite {Prolog_Deep_Learning}}}{10}{figure.caption.21}%
\contentsline {figure}{\numberline {2.10}{\ignorespaces Python converting user-specified constraints into Prolog queries \blx@tocontentsinit {0}\cite {Prolog_Deep_Learning}}}{10}{figure.caption.22}%
\contentsline {figure}{\numberline {2.11}{\ignorespaces Examples of dungeons generated using ASP \blx@tocontentsinit {0}\cite {pcgbook}}}{11}{figure.caption.23}%
\contentsline {figure}{\numberline {2.12}{\ignorespaces Generating a variation from a larger dungeon \blx@tocontentsinit {0}\cite {Graph_Constraint_Dungeon}}}{11}{figure.caption.24}%
\contentsline {figure}{\numberline {2.13}{\ignorespaces \textit {Zelda}-style levels being generated by a Random Level Generator (a), Constructive Level Generator (b) and Search-Based Level Generator (c) \blx@tocontentsinit {0}\cite {GVG-AI_and_VGDL_Level_Generators}}}{12}{figure.caption.25}%
\contentsline {figure}{\numberline {2.14}{\ignorespaces Comparing performance of \textit {Plotting} models and solvers \blx@tocontentsinit {0}\cite {Plotting_Planning_Problem}}}{12}{figure.caption.26}%
\contentsline {figure}{\numberline {2.15}{\ignorespaces \textit {Bad North} uses \acrshort {wfc} to generate islands traversable by AI \blx@tocontentsinit {0}\cite {badnorth}}}{13}{figure.caption.27}%
\contentsline {figure}{\numberline {2.16}{\ignorespaces Generating pillars of different lengths from input model pieces \blx@tocontentsinit {0}\cite {model_synthesis_diss}}}{14}{figure.caption.28}%
\contentsline {figure}{\numberline {2.17}{\ignorespaces The overlapping \acrshort {wfc} pipeline with \(3\times 3\) overlap \blx@tocontentsinit {0}\cite {WFC_ConstraintSolving_and_ML}}}{15}{figure.caption.30}%
\contentsline {figure}{\numberline {2.18}{\ignorespaces \textit {Caves of Qud}'s multi-pass approach to avoid homogeneity \blx@tocontentsinit {0}\cite {GDC_caves_of_qud}}}{16}{figure.caption.33}%
\contentsline {figure}{\numberline {2.19}{\ignorespaces Use of the global maximum constraint to limit water tiles \blx@tocontentsinit {0}\cite {WFC_Automatic_Rules_And_Better_Symmetries}}}{16}{figure.caption.34}%
\contentsline {figure}{\numberline {2.20}{\ignorespaces Use of the global minimum constraint to pre-place tiles \blx@tocontentsinit {0}\cite {WFC_Automatic_Rules_And_Better_Symmetries}}}{17}{figure.caption.35}%
\contentsline {figure}{\numberline {2.21}{\ignorespaces Use of the object distance constraint to improve object spawns \blx@tocontentsinit {0}\cite {WFC_Automatic_Rules_And_Better_Symmetries}}}{17}{figure.caption.36}%
\contentsline {figure}{\numberline {2.22}{\ignorespaces Use of the double-layer generation to ease object spawning \blx@tocontentsinit {0}\cite {WFC_Automatic_Rules_And_Better_Symmetries}}}{18}{figure.caption.37}%
\contentsline {figure}{\numberline {2.23}{\ignorespaces \textit {Caves of Qud}'s multi-pass approach to avoid overfitting \blx@tocontentsinit {0}\cite {GDC_caves_of_qud}}}{19}{figure.caption.39}%
\contentsline {figure}{\numberline {2.24}{\ignorespaces Comparing performance of \acrshort {wfc} with and without backtracking and global constraints. When using global constraints, backtracking significantly improves performance. \blx@tocontentsinit {0}\cite {WFC_ConstraintSolving_and_ML}}}{20}{figure.caption.41}%
\contentsline {figure}{\numberline {2.25}{\ignorespaces Large-scale game implementation with N-WFC and sub-complete tile set. First, it requires (a) one sub-complete tile set. Then the (b) Exterior Generation Process uses (c) Diagonal Generation Process to start generating. Each (d) sub-grid uses (e) I-WFC to find an accepted solution and overlap its edge with the adjacent sub-grids, forming a final solution. \blx@tocontentsinit {0}\cite {Nested_WFC}}}{20}{figure.caption.42}%
\contentsline {figure}{\numberline {2.26}{\ignorespaces Infinite game implementation with N-WFC and sub-complete tile set \blx@tocontentsinit {0}\cite {Nested_WFC}}}{21}{figure.caption.43}%
\contentsline {figure}{\numberline {2.27}{\ignorespaces A glimpse into the \acrshort {imib} pipeline. Each layer defines a small part of each chunk to run \acrshort {wfc} in. By clearing and running four overlapping layers, a full grid is generated. \blx@tocontentsinit {0}\cite {Infinite_Modifying_In_Blocks}}}{22}{figure.caption.44}%
\contentsline {figure}{\numberline {2.28}{\ignorespaces Placing nodes on a navigation mesh using graph-based \acrshort {wfc} \blx@tocontentsinit {0}\cite {WFC_Graph-based}}}{23}{figure.caption.46}%
\contentsline {figure}{\numberline {2.29}{\ignorespaces Using growing grid and \acrshort {wfc} to generate more complex worlds \blx@tocontentsinit {0}\cite {WFC_Neural_Network}}}{23}{figure.caption.47}%
\addvspace {10\p@ }
\addvspace {10\p@ }
\addvspace {10\p@ }
\addvspace {10\p@ }
\contentsline {figure}{\numberline {6.1}{\ignorespaces A \(3\times 3\) cell grid as an undirected and directed graph}}{29}{figure.caption.51}%
\contentsline {figure}{\numberline {6.2}{\ignorespaces Example starting state, in which all arcs are consistent}}{30}{figure.caption.52}%
\contentsline {figure}{\numberline {6.3}{\ignorespaces After assigning Cube to A, <B,A> is no longer consistent}}{30}{figure.caption.53}%
\contentsline {figure}{\numberline {6.4}{\ignorespaces Revising arc <B,A>}}{30}{figure.caption.54}%
\contentsline {figure}{\numberline {6.5}{\ignorespaces Revising <B,A> results in <C,B> becoming inconsistent}}{31}{figure.caption.55}%
\contentsline {figure}{\numberline {6.6}{\ignorespaces The graph after \acrshort {ac3} has been carried out}}{31}{figure.caption.56}%
\contentsline {figure}{\numberline {6.7}{\ignorespaces Examples of levels with three different cell selection techniques}}{33}{figure.caption.58}%
\contentsline {figure}{\numberline {6.8}{\ignorespaces Ascending tile selection has a high chance to generate unplayable levels such as this empty level}}{34}{figure.caption.60}%
\contentsline {figure}{\numberline {6.9}{\ignorespaces Examples of levels with four different tile weight configurations}}{35}{figure.caption.61}%
\contentsline {figure}{\numberline {6.10}{\ignorespaces \acrshort {imib} uses a grid of overlapping chunks consisting of overlapping layers}}{36}{figure.caption.62}%
\contentsline {figure}{\numberline {6.11}{\ignorespaces Clearing and generating layer 1 as part of \acrshort {imib}}}{36}{figure.caption.63}%
\contentsline {figure}{\numberline {6.12}{\ignorespaces Each \acrshort {imib} layer is generated in turn to compose a full result}}{37}{figure.caption.64}%
\contentsline {figure}{\numberline {6.13}{\ignorespaces Running \acrshort {imib} with \textit {The Backrooms} tile set}}{38}{figure.caption.65}%
\contentsline {figure}{\numberline {6.14}{\ignorespaces The chunks to unload and load in an infinite world can be mapped directly from their relative position to the player}}{38}{figure.caption.66}%
\contentsline {figure}{\numberline {6.15}{\ignorespaces The model tile set in Blender}}{40}{figure.caption.67}%
\contentsline {figure}{\numberline {6.16}{\ignorespaces Camera Effects}}{41}{figure.caption.68}%
\contentsline {figure}{\numberline {6.17}{\ignorespaces A comparison of forward and deferred lighting. Forward lighting fails to light the scene properly, showing distinct lines on tiles.}}{42}{figure.caption.69}%
\addvspace {10\p@ }
\contentsline {figure}{\numberline {7.1}{\ignorespaces A cell with cube, corner and wall tiles as options}}{43}{figure.caption.70}%
\contentsline {figure}{\numberline {7.2}{\ignorespaces The corner tile with all possible rotations (counted clockwise)}}{44}{figure.caption.71}%
\contentsline {figure}{\numberline {7.3}{\ignorespaces Comparison of valid wall placement to invalid wall placement if adjacent walls must have matching cardinality}}{45}{figure.caption.72}%
\contentsline {figure}{\numberline {7.4}{\ignorespaces A symmetric cube tile converted to a non-symmetric tile. For simplicity, the cube is only shown with a wall as its possible neighbour.}}{46}{figure.caption.73}%
\contentsline {figure}{\numberline {7.5}{\ignorespaces The array of explicit variants for the cube tile with neighbours shown. Due to the tile's symmetry, no extra work is needed to calculate variants for cardinalities 1, 2 and 3.}}{46}{figure.caption.74}%
\contentsline {figure}{\numberline {7.6}{\ignorespaces The array of explicit variants for the corner tile with neighbours shown.}}{47}{figure.caption.75}%
\contentsline {figure}{\numberline {7.7}{\ignorespaces The explicit corner tile variants before updating neighbours to their explicit forms}}{47}{figure.caption.76}%
\contentsline {figure}{\numberline {7.8}{\ignorespaces The three parts of the recursive \acrshort {mac3} method}}{50}{figure.caption.80}%
\addvspace {10\p@ }
\addvspace {10\p@ }
\addvspace {10\p@ }
\addvspace {10\p@ }
\addvspace {10\p@ }
\addvspace {10\p@ }
\addvspace {10\p@ }
