\chapter{Implementation}
% How the implementation was done and tested, with particular focus on important / novel algorithms and/or data structures, unusual implementation decisions, novel user interface features, etc.
% General Introduction: Language used. How it linked to the task. How the task progressed over time. Any changes over time.
% Specific Sections: Goal of each part. Purpose or context within larger whole. How each part works step by step. (STAR?)
\section{Cells}
\subsection{Cell Class}
The Cell class contains integer coordinates, a set of possible tile options and a tile prefab game object. These variables allow the cell to be used in a grid for level generation. The set of tile options is initialised with the entire fully-explicit tile set, with tiles removed as WFC is run on a grid including the cell. Once the cell has been collapsed, the assigned tile is instantiated and a reference to it preserved in the tile prefab field.

\subsection{CellArc Class}
The CellArc class is used to represent arcs in the grid. It simply contains references to two cells and ensures that the arc is valid. This is done by comparing the x and y coordinates of the cells when creating the arc. An exception is thrown when the cells are not adjacent.

\subsection{CellReference Class}
The CellReference class simply contains a reference to a cell. By inheriting from MonoBehaviour, a cell reference can be attached to a tile. This allows a reference to the cell to be kept even after a layer has been spawned, allowing the cell information to be used in future generation.

\section{Tiles}
\subsection{Rotation / Cardinality}
Each spawned tile has a cardinality of either 0, 1, 2 or 3. This corresponds to rotations of 0, 90, 180 and 270 degrees respectively. This information is used to determine which combination of two tiles and their rotations fits together. For example, a single wall tile constituting part of a longer wall will require any adjacent wall tiles to be of the same cardinality. The valid cardinality of each tile neighbour must be specified by the level designer when specifying the tile set.

\subsection{Tile Symmetry}\label{sec:tileSymmetry}
To reduce the amount of adjacency data to be specified by the level designer as well as the chance for human error, the level generator includes functions to convert a semi-explicit tile set into a fully-explicit tile set. This fully-explicit tile set is created at the start of generation.

First, it is checked whether the empty tile was specified and is included in the semi-explicit tile set. After confirming this, the main conversion stage begins.

% A bit unclear wording?
For each tile, a non-symmetric variant is created. First, a non-symmetric tile version of each tile in the tile set is instantiated. Second, an array for each possible tile rotation is created. This array is attached to the original tile to set explicit neighbours later. The instantiated tile is used as the base rotation and referenced in the array. From this base rotation tile, three other copies are created to obtain a variant for each possible rotation. These variants are also referenced in the array. For cube tiles, the base rotation tile can simply be referenced for each rotation instead of having to create additional copies.

% Image showing conversion of other tile types to non-symmetric. Also show how the array is filled.

For non-cube tiles, rotation variants must be created. Each new variant copies the previous one. This allows a loop to be used that always performs 90 degree steps. First, the tile is rotated by 90 degrees. Then, neighbour data and rotation arrays are swapped. This sets back neighbours as left neighours, left neighbours as front neighbours and so on. Finally, the cardinality values of all neighbours are increased by one to mark the 90 degree rotation.

% Diagram of process for non-cube tiles, including the rotation edits.

Once all the explicit variants have been generated, the neighbours of each tile can be set to the explicit variants. To do this, the array assigned to each tile containing all the explicit variants is used. For each neighbour of the explicit tile, the reference to the non-explicit neighbour is replaced by the explicit neighbour with the correct orientation.

% Diagram of this process.


% // Initialise the explicit tile set if it has not already been done.
    % // Ensure that the empty tile is in the tile set.
    % // Create a game object to hold the explicit tile set.
    % // Create non-symmetric variants for each tile.
        % // Create a non-symmetric copy of the original tile.
        % // Add the copy to the explicit tile set and set it as the 0 rotation variant.
        % // Set the explicit variant of the empty tile if applicable.
        %%%IF // Create rotation variants for non-cube tiles.
            % // Create a rotation variant with the previous rotation as the base.
            % // Rotate the variant by 90 degrees and specify its rotation / cardinality in the name.
            % // Add the variant to both the tile's variants array and the explicit tile set.
            % // Switch the neighbour and rotation arrays to follow the 90 degree rotation.
            % // Increase cardinality values of neighbours to account for the 90 degree rotation.
        %%%ELSE // For cube tiles, simply set the explicit rotation variants to be the 0 rotation non-symmetric tile.
        % // Replace the neighbours of each explicit tile without explicit rotational information with explicit variants accounting for the rotations.
            % // Use 2D arrays of the neighbours and rotations to simplify the operation.
            % // Go through each neighbour array and neighbour tile in it.
                % // Get the rotation / cardinality value of the variant to use.
                % // Set the neighbour to the explicit variant with the correct rotation.

\subsection{Collapsing Cells}
To collapse a tile into a cell, the tile's model is instantiated. Then, the model is set to follow the level generation manager's transform and has its local position set to the cell's world coordinates. Doing the placement like this ensures that the model lines up with the world grid while maintaining the correct scale and rotation. Finally, a box collider is added to the model, a second reference to the tile added to the cell and the model activated. The box collider helps with later generation as it can be detected when getting a previous cell's reference. The second reference ensures that the spawned tile can be recovered if generation of a layer fails.

% Diagram of the pipeline.
% Instantiate, place, add collider, reference and set active.

\section{Chunks}
Chunks are defined by their own chunk coordinates, which are converted from world coordinates using the chunk size as a divisor. From this, each of the chunk's four layers can be defined. Layer one is aligned with the chunk's world coordinates, while layer two is offset by half a chunk in the x direction. Layer three is similarly offset by half a chunk in the y direction, while layer four is offset both in the x and y directions. Each layer is given its own layer spawner instance, which runs WFC on the portion of the chunk defined by the layer.

% Chunk diagram with layer shown.

Each chunk has its own Random Number Generator (RNG), which is used by the layer spawners when making tile choices. The seed for the RNG is defined deterministically through the chunk's coordinates. The global level generation seed is added to allow generation of multiple levels while keeping determinism. This deterministic use of RNGs when spawning chunks is what allows the level generation manager to spawn chunks identically, even when unloading and loading a chunk again.

\section{Level Generation Manager}
\subsection{Prerequisites}
To start generation, the level designer must have defined a tile set for the generator to use. This must contain an empty tile and be convertible into an explicit tile set as detailed in Section \ref{sec:tileSymmetry}.

\subsection{Solver (Layer Spawners)}
The MAC3 solver code is held in the LayerSpawner class. This matches up with the idea of layers and chunks modifying the world in an infinite set of blocks. To allow accurate placement of tiles in the world, a starting cell coordinate must be passed when initialising the layer spawner. Furthermore, a reference to the layer's parent chunk is kept in order to utilise its random number generator.

\subsection{Grid Initialisation}
First, a grid of cells is initialised. Additionally, a list of cells left to assign is initialised to simplify cell choices when solving. Padding on the layer size is used to include any previously collapsed cells. If any padded cells have not been collapsed, they are treated as empty tiles. This padding means that non-padded cells take into account full adjacency information. If the layer were not padded, then border cells would not have arc consistency with cells outside of the layer as these arcs would not be checked by the solver. The non-padding cells in the centre of the grid are refreshed by resetting each cell's tile options set to include all possible tiles. This allows each each layer to re-generate its cells. In effect, this connects singular, overlapping layers into an infinite, continuous grid.% WHY Are non-collapsed cells treated as empty tiles? DOES THIS HELP STITCHING? EXPERIMENT AGAIN AND WRITE DOWN REASONING.

\subsection{Dealing with an Infinite Grid}
If every cell was stored in a global grid, then it would be trivially easy to get previously collapsed cells. This is unfeasible due to the requirement of letting the player navigate an infinite world. As such, once cells are collapsed, the grid used by the solver is discarded. Instead, the tile game object that was spawned in is given a `CellReference' component. This simply stores a reference to the cell instance used by the grid. As each tile has its own collider and the coordinates for a given cell can be obtained from the world coordinates, Unity's `Physics.OverlapBox' function can be used. This can obtain the collider of the tile given its world position, which can then be used to get the cell reference.% DISCUSS ALTERNATIVE IN EVALUATION. MAYBE A "SEMI-GLOBAL" GRID THAT CONTAINS ALL THE CURRENTLY COLLAPSED CELLS AND SHIFTS AS THE PLAYER MOVES.

\subsection{Setting up MAC3}
With the layer's grid fully initialised, the main stage of the solver can now begin. First, a stack of state changes is initialised. This tracks changes to cells after each assignment by pushing a new state change to the stack. To make the grid globally arc consistent, the arc of each cell in the grid is generated. Subsequently, AC3 is run with this starting queue of cell arcs.

\subsection{MAC3 Recursion}
After this, the first iteration of a recursive implementation of the MAC3 algorithm is called. Pseudocode of this is given below. How each step works and its purpose is explained in more detail in subsections following the pseudocode.

\begin{enumerate}
    \item If all cells have been assigned, return.
    \item Choose a cell and tile to assign as in Section \ref{sec:variableAndValueChoice}.
    \item Enter a new state and assign the tile to the cell, pruning other tiles from its tile options set.
    \item If the cell's tile options set changed, run AC3.
    \item Recurse if AC3 was not run or there was no domain wipeout during AC3.
    \item If all cells have been assigned, return.
    \item We are now in the case that a domain wipeout must have occurred. Revert the state.
    \item If the cell we tried to assign still has other options left, remove / `unassign' the tile we tried from the options, run AC3 and recurse again.
    \item If all cells have been assigned, return.
    \item We are now in the case that all possible tile values for a cell led to a wipeout. This means that an earlier choice must be to blame. Restore the tile we tried both to assign and unassign and return.
\end{enumerate}

\subsubsection{Managing State Changes}
To track state changes, each layer spawner holds a stack of state changes. After each time a new cell is chosen to be assigned, a new state is entered. A state change class is used that holds the cell being assigned and any domain changes occurring across the grid. Domain changes can happen to any cell and can consist of multiple tile changes, so a dictionary of cells to hash sets of tiles is used. To track a new state change, a new entry and hash set are added to the dictionary if required. After this, the hash set can be obtained from the dictionary through use of the cell and any tile changes added.

% Image of domain changes structure.

To revert a state, the domain changes dictionary is iterated through, with each cell having any removed tiles restored to its domain. Furthermore, the cell that was assigned in the state change is re-added to the list of cells left to assign.

\subsubsection{Assigning and Unassigning a Tile to a Cell}
Assigning a tile to a cell involves pruning all tiles except the one being assigned. These tiles are removed from the tile options set. Furthermore, each domain change is recorded in the current state changes. Finally, the assigned cell is removed from the list of cells left to assign. After this, AC3 can be run to maintain arc consistency.

% Image of assignment.

Unassigning a tile to a cell first requires the state to be reverted. After this, the opposite choice is taken. This is done by pruning only the tile choice that was previously assigned. This demonstrates the 2-way branching nature of the implementation. Rather than exploring all possible tile values in one level of search, each tile value is either assigned or unassigned.

\subsubsection{Visualising Recursion}
The recursive MAC3 method can be visualised as consisting of three parts as in Figure \ref{fig:mac3Recursion}.

\begin{figure}[H]
    \begin{framed}
    \begin{enumerate}
        \item Making a new assignment.
        \item Making the opposite assignment (``unassignment'') after the first one failed.
        \item Both assignments having failed.
    \end{enumerate}
    \end{framed}
    \caption{The three parts of the recursive MAC3 method}
    \label{fig:mac3Recursion}
\end{figure}

The finishing state of the grid is checked both before making the new assignment and after each of the assignments. This ensures that the recursion is finished immediately after consistency has been enforced from an assignment and each cell only has one value left.